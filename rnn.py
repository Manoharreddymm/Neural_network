# -*- coding: utf-8 -*-
"""RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nOzoBD1uevIKal7rAVPN9iHremKnz1E3
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, Dense
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
from datetime import datetime

# Load data
data = pd.read_csv('/content/drive/MyDrive/Neural_network/daily-min-temperatures.csv')
print(data.head())

data.info()

# Convert date column to datetime
data['Date'] = pd.to_datetime(data['Date'])
data.set_index('Date', inplace=True)
# Display the first few rows
print(data.head())

data.head()

data.info()

data.size

#Scale the temperature values to [0, 1] range
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data['Temp'].values.reshape(-1, 1))

scaled_data

#x=max(scaled_data)
#x

#x=min(scaled_data)
#x

plt.plot(scaled_data)
plt.xlabel('Days')
plt.ylabel('Temperature')
plt.show()

# Create sequences
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i + seq_length])
        y.append(data[i + seq_length])
    return np.array(X), np.array(y)
sequence_length = 30
X, y = create_sequences(scaled_data, sequence_length)

X.size

X.shape

x

y.size

# Split data into train and test sets
split_ratio = 0.8
train_size = int(len(X) * split_ratio)
X_train, y_train = X[:train_size], y[:train_size]
X_test, y_test = X[train_size:], y[train_size:]

# Build the RNN model
model = Sequential()
model.add(SimpleRNN(50, activation='relu', input_shape=(X_train.shape[1], 1)))
model.add(Dense(1))  # Output layer

model.compile(optimizer='adam', loss='mse')

# Train the model
history = model.fit(X_train, y_train, epochs=15, validation_data=(X_test, y_test), batch_size=8)

# Evaluate the model
train_loss = model.evaluate(X_train, y_train)
test_loss = model.evaluate(X_test, y_test)
print(f"Train Loss: {train_loss}, Test Loss: {test_loss}")

# Make predictions on the test set
predictions = model.predict(X_test)

# Inverse scale the predictions and test values
predictions = scaler.inverse_transform(predictions)
y_test = scaler.inverse_transform(y_test.reshape(-1, 1))

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(y_test, color='blue', label='Actual Temperatures')
plt.plot(predictions, color='red', linestyle='--', label='Predicted Temperatures')
plt.xlabel("Days")
plt.ylabel("Temperature")
plt.title("Temperature Prediction with RNN")
plt.legend()
plt.show()

# Take the last 30 time steps from the test set as a new input sequence
new_input = scaled_data[-30:]  # The last 30 scaled values
new_input = new_input.reshape(1, 30, 1)  # Reshape to (1, 30, 1)

# Predict the next time step
predicted_value = model.predict(new_input)

# Inverse scale the prediction to get the actual temperature
predicted_value = scaler.inverse_transform(predicted_value)
print("Predicted Value for the Next Time Step:", predicted_value[0][0])









